/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(2);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editor = __webpack_require__(3);

var _editor2 = _interopRequireDefault(_editor);

var _fs = __webpack_require__(6);

var _fs2 = _interopRequireDefault(_fs);

var _electron = __webpack_require__(7);

var _dispatcher = __webpack_require__(8);

var _dispatcher2 = _interopRequireDefault(_dispatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dialog = _electron.remote.dialog,
    Menu = _electron.remote.Menu,
    MenuItem = _electron.remote.MenuItem;


var template = [{
  label: 'File',
  submenu: [{ label: 'new file', click: function click() {
      _dispatcher2.default.dispatch({
        type: "NEW_FILE"
      });
    }
  }, { label: 'open file', click: function click() {
      dialog.showOpenDialog({ properties: ['openFile'], filters: [{ name: 'All Files', extensions: ['md'] }] }, function (filePath) {
        _dispatcher2.default.dispatch({
          type: "OPEN_FILE",
          'filePath': filePath.toString()
        });
      });
    }
  },
  // {label: 'save', click () {
  //   dispatcher.dispatch({
  //     type: "SAVE_FILE",
  //   });

  //     } },
  { label: 'save as', click: function click() {
      dialog.showSaveDialog({ properties: ['saveFileAs'], filters: [{ name: 'All Files', extensions: ['md'] }] }, function (filePath) {
        _dispatcher2.default.dispatch({
          type: "SAVE_FILE_AS",
          'filePath': filePath.toString()
        });
      });
    }
  }]
}, {
  label: 'Edit',
  submenu: [{ role: 'undo' }, { role: 'redo' }, { type: 'separator' }, { role: 'cut' }, { role: 'copy' }, { role: 'paste' }, { role: 'pasteandmatchstyle' }, { role: 'delete' }, { role: 'selectall' }]
}, {
  label: 'View',
  submenu: [{ role: 'reload' }, { role: 'forcereload' }, { role: 'toggledevtools' }, { type: 'separator' }, { role: 'resetzoom' }, { role: 'zoomin' }, { role: 'zoomout' }, { type: 'separator' }, { role: 'togglefullscreen' }]
}, {
  role: 'window',
  submenu: [{ role: 'minimize' }, { role: 'close' }]
}, {
  role: 'help',
  submenu: [{
    label: 'Learn More',
    click: function click() {
      __webpack_require__(7).shell.openExternal('https://electron.atom.io');
    }
  }]
}];
var menu = Menu.buildFromTemplate(template);
Menu.setApplicationMenu(menu);

// const menu = new Menu()
// menu.append(new MenuItem({label: 'MenuItem1', click() { console.log('item 1 clicked') }}))
// menu.append(new MenuItem({type: 'separator'}))
// menu.append(new MenuItem({label: 'MenuItem2', type: 'checkbox', checked: true}))

// window.addEventListener('contextmenu', (e) => {
//   e.preventDefault()
//   menu.popup(remote.getCurrentWindow())
// }, false)


// const filePath = dialog.showOpenDialog({properties: ['openFile'],filters:[{name: 'All Files', extensions: ['md']}]})

// dispatcher.dispatch({
//   type: "OPEN_FILE",
//   'filePath':filePath.toString(),
// });

// const source = fs.readFileSync(filePath.toString(),'utf8')


//console.log(dialog)

var source = '';

var app = document.querySelector('#app');
console.log('must work this or');

_reactDom2.default.render(_react2.default.createElement(_editor2.default, { source: source }), app);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("react-dom");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slate = __webpack_require__(4);

var _prismjs = __webpack_require__(5);

var _prismjs2 = _interopRequireDefault(_prismjs);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(9);

var _store2 = _interopRequireDefault(_store);

var _dispatcher = __webpack_require__(8);

var _dispatcher2 = _interopRequireDefault(_dispatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Add the markdown syntax to Prism.
 */

// eslint-disable-next-line
_prismjs2.default.languages.markdown = _prismjs2.default.languages.extend("markup", {}), _prismjs2.default.languages.insertBefore("markdown", "prolog", { blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, code: [{ pattern: /^(?: {4}|\t).+/m, alias: "keyword" }, { pattern: /``.+?``|`[^`\n]+`/, alias: "keyword" }], title: [{ pattern: /\w+.*(?:\r?\n|\r)(?:==+|--+)/, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#+.+/m, lookbehind: !0, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])([\t ]*\2){2,}(?=\s*$)/m, lookbehind: !0, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: !0, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: /(^|[^\\])(\*\*|__)(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/, lookbehind: !0, inside: { punctuation: /^\*\*|^__|\*\*$|__$/ } }, italic: { pattern: /(^|[^\\])([*_])(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/, lookbehind: !0, inside: { punctuation: /^[*_]|[*_]$/ } }, url: { pattern: /!?\[[^\]]+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)| ?\[[^\]\n]*\])/, inside: { variable: { pattern: /(!?\[)[^\]]+(?=\]$)/, lookbehind: !0 }, string: { pattern: /"(?:\\.|[^"\\])*"(?=\)$)/ } } } }), _prismjs2.default.languages.markdown.bold.inside.url = _prismjs2.default.util.clone(_prismjs2.default.languages.markdown.url), _prismjs2.default.languages.markdown.italic.inside.url = _prismjs2.default.util.clone(_prismjs2.default.languages.markdown.url), _prismjs2.default.languages.markdown.bold.inside.italic = _prismjs2.default.util.clone(_prismjs2.default.languages.markdown.italic), _prismjs2.default.languages.markdown.italic.inside.bold = _prismjs2.default.util.clone(_prismjs2.default.languages.markdown.bold);

/**
 * Define a decorator for markdown styles.
 *
 * @param {Text} text
 * @param {Block} block
 */

function markdownDecorator(text, block) {
  var characters = text.characters.asMutable();
  var language = 'markdown';
  var string = text.text;
  var grammar = _prismjs2.default.languages[language];
  var tokens = _prismjs2.default.tokenize(string, grammar);
  addMarks(characters, tokens, 0);
  return characters.asImmutable();
}

function codeH(text, block) {
  console.log('text', text);
  console.log('block', block);
  var characters = text.characters.asMutable();
  return characters.asImmutable();
}

function CodeBlock(props) {
  console.log('block');
  var editor = props.editor,
      node = props.node;

  var language = 'javascript';

  function onChange(e) {
    var state = editor.getState();
    var next = state.transform().setNodeByKey(node.key, {
      data: {
        language: e.target.value
      }
    }).apply();
    editor.onChange(next);
  }
}

function addMarks(characters, tokens, offset) {
  // console.log('char',characters)
  // console.log('token',tokens)
  // console.log('offset',offset)
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var token = _step.value;

      if (typeof token == 'string') {
        offset += token.length;
        continue;
      }

      var content = token.content,
          length = token.length,
          type = token.type;

      var mark = _slate.Mark.create({ type: type });

      for (var i = offset; i < offset + length; i++) {
        var char = characters.get(i);
        var _char = char,
            marks = _char.marks;

        marks = marks.add(mark);
        char = char.set('marks', marks);
        characters.set(i, char);
      }

      if (Array.isArray(content)) {
        addMarks(characters, content, offset);
      }

      offset += length;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

/**
 * Define a schema.
 *
 * @type {Object}
 */

var schema = {
  nodes: {},

  marks: {
    'title': {
      fontWeight: 'bold',
      fontSize: '18px',
      margin: '0 0 8px 0',
      display: 'inline-block',
      color: "#569CD6"
    },
    'bold': {
      fontWeight: 'bold',
      color: "#569CD6"
    },
    'italic': {
      fontStyle: 'italic'
    },
    'punctuation': {
      opacity: 0.6
    },
    'code': {
      fontFamily: 'monospace',
      display: 'inline-block',
      padding: '2px 1px',
      color: '#CE915E',
      direction: 'ltr'
    },
    'list': {
      paddingLeft: '5px',
      lineHeight: '16px',
      color: "#569CD6"
    },
    'hr': {

      display: 'block',
      opacity: 0.5
    }
  },
  rules: [{
    match: function match() {
      return true;
    },
    decorate: markdownDecorator

  }]

  /**
   * The markdown preview example.
   *
   * @type {Component}
   */

};
var MarkdownPreview = function (_React$Component) {
  _inherits(MarkdownPreview, _React$Component);

  /**
   * Deserialize the initial editor state.
   *
   * @type {Object}
   */
  function MarkdownPreview() {
    _classCallCheck(this, MarkdownPreview);

    var _this = _possibleConstructorReturn(this, (MarkdownPreview.__proto__ || Object.getPrototypeOf(MarkdownPreview)).call(this));

    _this.style = {
      backgroundColor: '#1E1E1E',
      color: '#D4D4D4'

      /**
       *
       * Render the example.
       *
       * @return {Component} component
       */

    };

    _this.onChange = function (state) {
      //this.setState({ state })
      _dispatcher2.default.dispatch({
        type: "UPDATE_CONTENT",
        state: state
      });
    };

    _this.state = { state: _store2.default.getContent() };
    return _this;
  }

  _createClass(MarkdownPreview, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _this2 = this;

      _store2.default.on("content update", function (state) {
        _this2.setState({ state: state });
      });
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { style: this.style },
        _react2.default.createElement(
          'p',
          { style: { textAlign: 'center' } },
          _store2.default.fileName
        ),
        _react2.default.createElement(_slate.Editor, {
          schema: schema,
          state: this.state.state,
          onChange: this.onChange.bind(this)
        })
      );
    }

    /**
     * On change.
     *
     * @param {State} state
     */

  }]);

  return MarkdownPreview;
}(_react2.default.Component);

/**
 * Export.
 */

exports.default = MarkdownPreview;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("slate");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("prismjs");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("electron");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _require = __webpack_require__(10),
    Dispatcher = _require.Dispatcher;

module.exports = new Dispatcher();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(13);

var _dispatcher = __webpack_require__(8);

var _dispatcher2 = _interopRequireDefault(_dispatcher);

var _slate = __webpack_require__(4);

var _fs = __webpack_require__(6);

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DocStore = function (_EventEmitter) {
  _inherits(DocStore, _EventEmitter);

  function DocStore() {
    _classCallCheck(this, DocStore);

    var _this = _possibleConstructorReturn(this, (DocStore.__proto__ || Object.getPrototypeOf(DocStore)).call(this));

    _this.content = _slate.Plain.deserialize("");
    _this.fileName = 'undifien';
    _this.filePath = undefined;
    return _this;
  }

  _createClass(DocStore, [{
    key: 'getContent',
    value: function getContent() {
      return this.content;
    }
  }, {
    key: 'updateContent',
    value: function updateContent(text) {
      this.content = text;
      this.saveFile();
      this.emit('content update', this.content);
    }
  }, {
    key: 'changeFile',
    value: function changeFile(filePath) {
      console.log('file', filePath);
      var file = _fs2.default.readFileSync(filePath, 'utf8');
      this.content = _slate.Plain.deserialize(file);
      this.filePath = filePath;
      var p = this.filePath.split('/');
      this.fileName = p[p.length - 1];
      this.emit('content update', this.content);
    }
  }, {
    key: 'saveFile',
    value: function saveFile() {
      if (this.filePath) {
        var fileSource = _slate.Plain.serialize(this.content);
        _fs2.default.writeFileSync(this.filePath, fileSource, 'utf8');
      }
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.content = _slate.Plain.deserialize("");
      this.fileName = 'undifien';
      this.filePath = undefined;
      this.emit('content update', this.content);
    }
  }, {
    key: 'saveNewFile',
    value: function saveNewFile(filePath) {
      this.fileName = filePath;
      var p = this.filePath.split('/');
      this.fileName = p[p.length - 1];
      var fileSource = _slate.Plain.serialize(this.content);
      _fs2.default.writeFileSync(filePath, fileSource, 'utf8');
      // console.log('save',this.content.texts)
    }
  }, {
    key: 'handleActions',
    value: function handleActions(action) {

      switch (action.type) {
        case "UPDATE_CONTENT":
          {
            this.updateContent(action.state);
            break;
          }
        case "OPEN_FILE":
          {
            this.changeFile(action.filePath);
            break;
          }
        case "NEW_FILE":
          {
            this.reset();
            break;
          }
        case "SAVE_FILE_AS":
          {
            this.saveNewFile(action.filePath);
            break;
          }
      }
    }
  }]);

  return DocStore;
}(_events.EventEmitter);

var docStore = new DocStore();
_dispatcher2.default.register(docStore.handleActions.bind(docStore));

exports.default = docStore;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = __webpack_require__(11);


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */



exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = __webpack_require__(12);

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZmM1NjU2OTExN2NiOWZiMjA5OGEiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicmVhY3RcIiIsIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1kb21cIiIsIndlYnBhY2s6Ly8vLi9hcHAvZWRpdG9yLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInNsYXRlXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicHJpc21qc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImZzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZWxlY3Ryb25cIiIsIndlYnBhY2s6Ly8vLi9hcHAvZGlzcGF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9mbHV4L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZmx1eC9saWIvRGlzcGF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiJdLCJuYW1lcyI6WyJkaWFsb2ciLCJNZW51IiwiTWVudUl0ZW0iLCJ0ZW1wbGF0ZSIsImxhYmVsIiwic3VibWVudSIsImNsaWNrIiwiZGlzcGF0Y2giLCJ0eXBlIiwic2hvd09wZW5EaWFsb2ciLCJwcm9wZXJ0aWVzIiwiZmlsdGVycyIsIm5hbWUiLCJleHRlbnNpb25zIiwiZmlsZVBhdGgiLCJ0b1N0cmluZyIsInNob3dTYXZlRGlhbG9nIiwicm9sZSIsInJlcXVpcmUiLCJzaGVsbCIsIm9wZW5FeHRlcm5hbCIsIm1lbnUiLCJidWlsZEZyb21UZW1wbGF0ZSIsInNldEFwcGxpY2F0aW9uTWVudSIsInNvdXJjZSIsImFwcCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNvbnNvbGUiLCJsb2ciLCJyZW5kZXIiLCJsYW5ndWFnZXMiLCJtYXJrZG93biIsImV4dGVuZCIsImluc2VydEJlZm9yZSIsImJsb2NrcXVvdGUiLCJwYXR0ZXJuIiwiYWxpYXMiLCJjb2RlIiwidGl0bGUiLCJpbnNpZGUiLCJwdW5jdHVhdGlvbiIsImxvb2tiZWhpbmQiLCJociIsImxpc3QiLCJ2YXJpYWJsZSIsInN0cmluZyIsImJvbGQiLCJpdGFsaWMiLCJ1cmwiLCJ1dGlsIiwiY2xvbmUiLCJtYXJrZG93bkRlY29yYXRvciIsInRleHQiLCJibG9jayIsImNoYXJhY3RlcnMiLCJhc011dGFibGUiLCJsYW5ndWFnZSIsImdyYW1tYXIiLCJ0b2tlbnMiLCJ0b2tlbml6ZSIsImFkZE1hcmtzIiwiYXNJbW11dGFibGUiLCJjb2RlSCIsIkNvZGVCbG9jayIsInByb3BzIiwiZWRpdG9yIiwibm9kZSIsIm9uQ2hhbmdlIiwiZSIsInN0YXRlIiwiZ2V0U3RhdGUiLCJuZXh0IiwidHJhbnNmb3JtIiwic2V0Tm9kZUJ5S2V5Iiwia2V5IiwiZGF0YSIsInRhcmdldCIsInZhbHVlIiwiYXBwbHkiLCJvZmZzZXQiLCJ0b2tlbiIsImxlbmd0aCIsImNvbnRlbnQiLCJtYXJrIiwiY3JlYXRlIiwiaSIsImNoYXIiLCJnZXQiLCJtYXJrcyIsImFkZCIsInNldCIsIkFycmF5IiwiaXNBcnJheSIsInNjaGVtYSIsIm5vZGVzIiwiZm9udFdlaWdodCIsImZvbnRTaXplIiwibWFyZ2luIiwiZGlzcGxheSIsImNvbG9yIiwiZm9udFN0eWxlIiwib3BhY2l0eSIsImZvbnRGYW1pbHkiLCJwYWRkaW5nIiwiZGlyZWN0aW9uIiwicGFkZGluZ0xlZnQiLCJsaW5lSGVpZ2h0IiwicnVsZXMiLCJtYXRjaCIsImRlY29yYXRlIiwiTWFya2Rvd25QcmV2aWV3Iiwic3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJnZXRDb250ZW50Iiwib24iLCJzZXRTdGF0ZSIsInRleHRBbGlnbiIsImZpbGVOYW1lIiwiYmluZCIsIkNvbXBvbmVudCIsIkRpc3BhdGNoZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwiRG9jU3RvcmUiLCJkZXNlcmlhbGl6ZSIsInVuZGVmaW5lZCIsInNhdmVGaWxlIiwiZW1pdCIsImZpbGUiLCJyZWFkRmlsZVN5bmMiLCJwIiwic3BsaXQiLCJmaWxlU291cmNlIiwic2VyaWFsaXplIiwid3JpdGVGaWxlU3luYyIsImFjdGlvbiIsInVwZGF0ZUNvbnRlbnQiLCJjaGFuZ2VGaWxlIiwicmVzZXQiLCJzYXZlTmV3RmlsZSIsImRvY1N0b3JlIiwicmVnaXN0ZXIiLCJoYW5kbGVBY3Rpb25zIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REEsa0M7Ozs7Ozs7OztBQ0NBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztJQUNPQSxNLG9CQUFBQSxNO0lBQU9DLEksb0JBQUFBLEk7SUFBTUMsUSxvQkFBQUEsUTs7O0FBRXBCLElBQU1DLFdBQVcsQ0FDZjtBQUNFQyxTQUFPLE1BRFQ7QUFFRUMsV0FBUyxDQUNQLEVBQUNELE9BQU8sVUFBUixFQUFvQkUsS0FBcEIsbUJBQTZCO0FBQzNCLDJCQUFXQyxRQUFYLENBQW9CO0FBQ2xCQyxjQUFNO0FBRFksT0FBcEI7QUFLRTtBQU5KLEdBRE8sRUFRSixFQUFDSixPQUFPLFdBQVIsRUFBcUJFLEtBQXJCLG1CQUE4QjtBQUM3Qk4s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LDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCw0Qjs7Ozs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDdERBLG1DIiwiZmlsZSI6InNjcmlwdC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBmYzU2NTY5MTE3Y2I5ZmIyMDk4YSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERvbSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgRWRpdG9yIGZyb20gJy4vZWRpdG9yJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHtyZW1vdGV9IGZyb20gJ2VsZWN0cm9uJ1xuaW1wb3J0IGRpc3BhdGNoZXIgZnJvbSAnLi9kaXNwYXRjaGVyJ1xuY29uc3Qge2RpYWxvZyxNZW51LCBNZW51SXRlbX0gPXJlbW90ZVxuXG5jb25zdCB0ZW1wbGF0ZSA9IFtcbiAge1xuICAgIGxhYmVsOiAnRmlsZScsXG4gICAgc3VibWVudTogW1xuICAgICAge2xhYmVsOiAnbmV3IGZpbGUnLCBjbGljayAoKSB7XG4gICAgICAgIGRpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IFwiTkVXX0ZJTEVcIixcbiAgICAgICAgfSk7XG4gICAgICAgXG4gICAgICAgIFxuICAgICAgICAgfSB9LFxuICAgICAgICAge2xhYmVsOiAnb3BlbiBmaWxlJywgY2xpY2sgKCkge1xuICAgICAgICAgIGRpYWxvZy5zaG93T3BlbkRpYWxvZyh7cHJvcGVydGllczogWydvcGVuRmlsZSddLGZpbHRlcnM6W3tuYW1lOiAnQWxsIEZpbGVzJywgZXh0ZW5zaW9uczogWydtZCddfV19LGZpbGVQYXRoID0+e1xuICAgICAgICAgICBkaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICB0eXBlOiBcIk9QRU5fRklMRVwiLFxuICAgICAgICAgICAgICdmaWxlUGF0aCc6ZmlsZVBhdGgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAvLyB7bGFiZWw6ICdzYXZlJywgY2xpY2sgKCkge1xuICAgICAgICAgICAgLy8gICBkaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIC8vICAgICB0eXBlOiBcIlNBVkVfRklMRVwiLFxuICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gICAgIH0gfSxcbiAgICAgICAgICAgICAgICB7bGFiZWw6ICdzYXZlIGFzJywgY2xpY2sgKCkge1xuICAgICAgICAgICAgICAgICAgZGlhbG9nLnNob3dTYXZlRGlhbG9nKHtwcm9wZXJ0aWVzOiBbJ3NhdmVGaWxlQXMnXSxmaWx0ZXJzOlt7bmFtZTogJ0FsbCBGaWxlcycsIGV4dGVuc2lvbnM6IFsnbWQnXX1dfSxmaWxlUGF0aCA9PntcbiAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiU0FWRV9GSUxFX0FTXCIsXG4gICAgICAgICAgICAgICAgICAgICAnZmlsZVBhdGgnOmZpbGVQYXRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9IH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ0VkaXQnLFxuICAgIHN1Ym1lbnU6IFtcbiAgICAgIHtyb2xlOiAndW5kbyd9LFxuICAgICAge3JvbGU6ICdyZWRvJ30sXG4gICAgICB7dHlwZTogJ3NlcGFyYXRvcid9LFxuICAgICAge3JvbGU6ICdjdXQnfSxcbiAgICAgIHtyb2xlOiAnY29weSd9LFxuICAgICAge3JvbGU6ICdwYXN0ZSd9LFxuICAgICAge3JvbGU6ICdwYXN0ZWFuZG1hdGNoc3R5bGUnfSxcbiAgICAgIHtyb2xlOiAnZGVsZXRlJ30sXG4gICAgICB7cm9sZTogJ3NlbGVjdGFsbCd9XG4gICAgXVxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdWaWV3JyxcbiAgICBzdWJtZW51OiBbXG4gICAgICB7cm9sZTogJ3JlbG9hZCd9LFxuICAgICAge3JvbGU6ICdmb3JjZXJlbG9hZCd9LFxuICAgICAge3JvbGU6ICd0b2dnbGVkZXZ0b29scyd9LFxuICAgICAge3R5cGU6ICdzZXBhcmF0b3InfSxcbiAgICAgIHtyb2xlOiAncmVzZXR6b29tJ30sXG4gICAgICB7cm9sZTogJ3pvb21pbid9LFxuICAgICAge3JvbGU6ICd6b29tb3V0J30sXG4gICAgICB7dHlwZTogJ3NlcGFyYXRvcid9LFxuICAgICAge3JvbGU6ICd0b2dnbGVmdWxsc2NyZWVuJ31cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByb2xlOiAnd2luZG93JyxcbiAgICBzdWJtZW51OiBbXG4gICAgICB7cm9sZTogJ21pbmltaXplJ30sXG4gICAgICB7cm9sZTogJ2Nsb3NlJ31cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByb2xlOiAnaGVscCcsXG4gICAgc3VibWVudTogW1xuICAgICAge1xuICAgICAgICBsYWJlbDogJ0xlYXJuIE1vcmUnLFxuICAgICAgICBjbGljayAoKSB7IHJlcXVpcmUoJ2VsZWN0cm9uJykuc2hlbGwub3BlbkV4dGVybmFsKCdodHRwczovL2VsZWN0cm9uLmF0b20uaW8nKSB9XG4gICAgICB9XG4gICAgXVxuICB9XG5dXG5jb25zdCBtZW51ID0gTWVudS5idWlsZEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSlcbk1lbnUuc2V0QXBwbGljYXRpb25NZW51KG1lbnUpXG5cbi8vIGNvbnN0IG1lbnUgPSBuZXcgTWVudSgpXG4vLyBtZW51LmFwcGVuZChuZXcgTWVudUl0ZW0oe2xhYmVsOiAnTWVudUl0ZW0xJywgY2xpY2soKSB7IGNvbnNvbGUubG9nKCdpdGVtIDEgY2xpY2tlZCcpIH19KSlcbi8vIG1lbnUuYXBwZW5kKG5ldyBNZW51SXRlbSh7dHlwZTogJ3NlcGFyYXRvcid9KSlcbi8vIG1lbnUuYXBwZW5kKG5ldyBNZW51SXRlbSh7bGFiZWw6ICdNZW51SXRlbTInLCB0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiB0cnVlfSkpXG5cbi8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiB7XG4vLyAgIGUucHJldmVudERlZmF1bHQoKVxuLy8gICBtZW51LnBvcHVwKHJlbW90ZS5nZXRDdXJyZW50V2luZG93KCkpXG4vLyB9LCBmYWxzZSlcblxuXG4vLyBjb25zdCBmaWxlUGF0aCA9IGRpYWxvZy5zaG93T3BlbkRpYWxvZyh7cHJvcGVydGllczogWydvcGVuRmlsZSddLGZpbHRlcnM6W3tuYW1lOiAnQWxsIEZpbGVzJywgZXh0ZW5zaW9uczogWydtZCddfV19KVxuXG4vLyBkaXNwYXRjaGVyLmRpc3BhdGNoKHtcbi8vICAgdHlwZTogXCJPUEVOX0ZJTEVcIixcbi8vICAgJ2ZpbGVQYXRoJzpmaWxlUGF0aC50b1N0cmluZygpLFxuLy8gfSk7XG5cbi8vIGNvbnN0IHNvdXJjZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aC50b1N0cmluZygpLCd1dGY4JylcblxuXG5cbi8vY29uc29sZS5sb2coZGlhbG9nKVxuXG5jb25zdCBzb3VyY2UgPSAnJ1xuXG5cbmNvbnN0IGFwcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhcHAnKVxuY29uc29sZS5sb2coJ211c3Qgd29yayB0aGlzIG9yJylcblxuUmVhY3REb20ucmVuZGVyKDxFZGl0b3Igc291cmNlID0ge3NvdXJjZX0vPixhcHApXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL21haW4uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWFjdC1kb21cIlxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmltcG9ydCB7IEVkaXRvciwgTWFyaywgUGxhaW4gfSBmcm9tICdzbGF0ZSdcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJ1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IERvY1N0b3JlIGZyb20gJy4vc3RvcmUnXG5pbXBvcnQgZGlzcGF0Y2hlciBmcm9tICcuL2Rpc3BhdGNoZXInXG5cbi8qKlxuICogQWRkIHRoZSBtYXJrZG93biBzeW50YXggdG8gUHJpc20uXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5QcmlzbS5sYW5ndWFnZXMubWFya2Rvd249UHJpc20ubGFuZ3VhZ2VzLmV4dGVuZChcIm1hcmt1cFwiLHt9KSxQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFwibWFya2Rvd25cIixcInByb2xvZ1wiLHtibG9ja3F1b3RlOntwYXR0ZXJuOi9ePig/OltcXHQgXSo+KSovbSxhbGlhczpcInB1bmN0dWF0aW9uXCJ9LGNvZGU6W3twYXR0ZXJuOi9eKD86IHs0fXxcXHQpLisvbSxhbGlhczpcImtleXdvcmRcIn0se3BhdHRlcm46L2BgLis/YGB8YFteYFxcbl0rYC8sYWxpYXM6XCJrZXl3b3JkXCJ9XSx0aXRsZTpbe3BhdHRlcm46L1xcdysuKig/Olxccj9cXG58XFxyKSg/Oj09K3wtLSspLyxhbGlhczpcImltcG9ydGFudFwiLGluc2lkZTp7cHVuY3R1YXRpb246Lz09KyR8LS0rJC99fSx7cGF0dGVybjovKF5cXHMqKSMrLisvbSxsb29rYmVoaW5kOiEwLGFsaWFzOlwiaW1wb3J0YW50XCIsaW5zaWRlOntwdW5jdHVhdGlvbjovXiMrfCMrJC99fV0saHI6e3BhdHRlcm46LyheXFxzKikoWyotXSkoW1xcdCBdKlxcMil7Mix9KD89XFxzKiQpL20sbG9va2JlaGluZDohMCxhbGlhczpcInB1bmN0dWF0aW9uXCJ9LGxpc3Q6e3BhdHRlcm46LyheXFxzKikoPzpbKistXXxcXGQrXFwuKSg/PVtcXHQgXS4pL20sbG9va2JlaGluZDohMCxhbGlhczpcInB1bmN0dWF0aW9uXCJ9LFwidXJsLXJlZmVyZW5jZVwiOntwYXR0ZXJuOi8hP1xcW1teXFxdXStcXF06W1xcdCBdKyg/OlxcUyt8PCg/OlxcXFwufFtePlxcXFxdKSs+KSg/OltcXHQgXSsoPzpcIig/OlxcXFwufFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwufFteJ1xcXFxdKSonfFxcKCg/OlxcXFwufFteKVxcXFxdKSpcXCkpKT8vLGluc2lkZTp7dmFyaWFibGU6e3BhdHRlcm46L14oIT9cXFspW15cXF1dKy8sbG9va2JlaGluZDohMH0sc3RyaW5nOi8oPzpcIig/OlxcXFwufFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwufFteJ1xcXFxdKSonfFxcKCg/OlxcXFwufFteKVxcXFxdKSpcXCkpJC8scHVuY3R1YXRpb246L15bXFxbXFxdITpdfFs8Pl0vfSxhbGlhczpcInVybFwifSxib2xkOntwYXR0ZXJuOi8oXnxbXlxcXFxdKShcXCpcXCp8X18pKD86KD86XFxyP1xcbnxcXHIpKD8hXFxyP1xcbnxcXHIpfC4pKz9cXDIvLGxvb2tiZWhpbmQ6ITAsaW5zaWRlOntwdW5jdHVhdGlvbjovXlxcKlxcKnxeX198XFwqXFwqJHxfXyQvfX0saXRhbGljOntwYXR0ZXJuOi8oXnxbXlxcXFxdKShbKl9dKSg/Oig/Olxccj9cXG58XFxyKSg/IVxccj9cXG58XFxyKXwuKSs/XFwyLyxsb29rYmVoaW5kOiEwLGluc2lkZTp7cHVuY3R1YXRpb246L15bKl9dfFsqX10kL319LHVybDp7cGF0dGVybjovIT9cXFtbXlxcXV0rXFxdKD86XFwoW15cXHMpXSsoPzpbXFx0IF0rXCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwiKT9cXCl8ID9cXFtbXlxcXVxcbl0qXFxdKS8saW5zaWRlOnt2YXJpYWJsZTp7cGF0dGVybjovKCE/XFxbKVteXFxdXSsoPz1cXF0kKS8sbG9va2JlaGluZDohMH0sc3RyaW5nOntwYXR0ZXJuOi9cIig/OlxcXFwufFteXCJcXFxcXSkqXCIoPz1cXCkkKS99fX19KSxQcmlzbS5sYW5ndWFnZXMubWFya2Rvd24uYm9sZC5pbnNpZGUudXJsPVByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duLnVybCksUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duLml0YWxpYy5pbnNpZGUudXJsPVByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duLnVybCksUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duLmJvbGQuaW5zaWRlLml0YWxpYz1QcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlcy5tYXJrZG93bi5pdGFsaWMpLFByaXNtLmxhbmd1YWdlcy5tYXJrZG93bi5pdGFsaWMuaW5zaWRlLmJvbGQ9UHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMubWFya2Rvd24uYm9sZCk7XG5cbi8qKlxuICogRGVmaW5lIGEgZGVjb3JhdG9yIGZvciBtYXJrZG93biBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge0Jsb2NrfSBibG9ja1xuICovXG5cbmZ1bmN0aW9uIG1hcmtkb3duRGVjb3JhdG9yKHRleHQsIGJsb2NrKSB7XG4gIGNvbnN0IGNoYXJhY3RlcnMgPSB0ZXh0LmNoYXJhY3RlcnMuYXNNdXRhYmxlKClcbiAgY29uc3QgbGFuZ3VhZ2UgPSAnbWFya2Rvd24nXG4gIGNvbnN0IHN0cmluZyA9IHRleHQudGV4dFxuICBjb25zdCBncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXVxuICBjb25zdCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShzdHJpbmcsIGdyYW1tYXIpXG4gIGFkZE1hcmtzKGNoYXJhY3RlcnMsIHRva2VucywgMClcbiAgcmV0dXJuIGNoYXJhY3RlcnMuYXNJbW11dGFibGUoKVxufVxuXG5mdW5jdGlvbiBjb2RlSCh0ZXh0LCBibG9jayl7XG4gIGNvbnNvbGUubG9nKCd0ZXh0Jyx0ZXh0KVxuICBjb25zb2xlLmxvZygnYmxvY2snLGJsb2NrKVxuICBjb25zdCBjaGFyYWN0ZXJzID0gdGV4dC5jaGFyYWN0ZXJzLmFzTXV0YWJsZSgpXG4gIHJldHVybiBjaGFyYWN0ZXJzLmFzSW1tdXRhYmxlKClcbn1cblxuZnVuY3Rpb24gQ29kZUJsb2NrKHByb3BzKSB7XG4gIGNvbnNvbGUubG9nKCdibG9jaycpXG4gIGNvbnN0IHsgZWRpdG9yLCBub2RlIH0gPSBwcm9wc1xuICBjb25zdCBsYW5ndWFnZSA9ICdqYXZhc2NyaXB0J1xuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGVkaXRvci5nZXRTdGF0ZSgpXG4gICAgY29uc3QgbmV4dCA9IHN0YXRlXG4gICAgICAudHJhbnNmb3JtKClcbiAgICAgIC5zZXROb2RlQnlLZXkobm9kZS5rZXksIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGxhbmd1YWdlOiBlLnRhcmdldC52YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmFwcGx5KClcbiAgICBlZGl0b3Iub25DaGFuZ2UobmV4dClcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRNYXJrcyhjaGFyYWN0ZXJzLCB0b2tlbnMsIG9mZnNldCkge1xuICAvLyBjb25zb2xlLmxvZygnY2hhcicsY2hhcmFjdGVycylcbiAgLy8gY29uc29sZS5sb2coJ3Rva2VuJyx0b2tlbnMpXG4gIC8vIGNvbnNvbGUubG9nKCdvZmZzZXQnLG9mZnNldClcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09ICdzdHJpbmcnKSB7XG4gICAgICBvZmZzZXQgKz0gdG9rZW4ubGVuZ3RoXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IHsgY29udGVudCwgbGVuZ3RoLCB0eXBlIH0gPSB0b2tlblxuICAgIGNvbnN0IG1hcmsgPSBNYXJrLmNyZWF0ZSh7IHR5cGUgfSlcblxuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyBsZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoYXIgPSBjaGFyYWN0ZXJzLmdldChpKVxuICAgICAgbGV0IHsgbWFya3MgfSA9IGNoYXJcbiAgICAgIG1hcmtzID0gbWFya3MuYWRkKG1hcmspXG4gICAgICBjaGFyID0gY2hhci5zZXQoJ21hcmtzJywgbWFya3MpXG4gICAgICBjaGFyYWN0ZXJzLnNldChpLCBjaGFyKVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICBhZGRNYXJrcyhjaGFyYWN0ZXJzLCBjb250ZW50LCBvZmZzZXQpXG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IGxlbmd0aFxuICB9XG59XG5cbi8qKlxuICogRGVmaW5lIGEgc2NoZW1hLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3Qgc2NoZW1hID0ge1xuICBub2Rlczoge1xuICB9XG4gICxcbiAgbWFya3M6IHtcbiAgICAndGl0bGUnOiB7XG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICBmb250U2l6ZTogJzE4cHgnLFxuICAgICAgbWFyZ2luOiAnMCAwIDhweCAwJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgY29sb3I6IFwiIzU2OUNENlwiXG4gICAgfSxcbiAgICAnYm9sZCc6IHtcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIGNvbG9yOiBcIiM1NjlDRDZcIlxuICAgIH0sXG4gICAgJ2l0YWxpYyc6IHtcbiAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYydcbiAgICB9LFxuICAgICdwdW5jdHVhdGlvbic6IHtcbiAgICAgIG9wYWNpdHk6IDAuNlxuICAgIH0sXG4gICAgJ2NvZGUnOiB7XG4gICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgcGFkZGluZzogJzJweCAxcHgnLFxuICAgICAgY29sb3I6ICcjQ0U5MTVFJyxcbiAgICAgIGRpcmVjdGlvbjogJ2x0cidcbiAgICB9LFxuICAgICdsaXN0Jzoge1xuICAgICAgcGFkZGluZ0xlZnQ6ICc1cHgnLFxuICAgICAgbGluZUhlaWdodDogJzE2cHgnLFxuICAgICAgY29sb3I6IFwiIzU2OUNENlwiXG4gICAgfSxcbiAgICAnaHInOiB7XG4gICAgICBcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICBvcGFjaXR5OiAwLjUsXG4gICAgfVxuICB9LFxuICBydWxlczogW1xuICAgIHtcbiAgICAgIG1hdGNoOiAoKSA9PiB0cnVlLFxuICAgICAgZGVjb3JhdGU6IG1hcmtkb3duRGVjb3JhdG9yXG5cbiAgICB9XG4gIF0sXG4gICAgXG4gIFxufVxuXG4vKipcbiAqIFRoZSBtYXJrZG93biBwcmV2aWV3IGV4YW1wbGUuXG4gKlxuICogQHR5cGUge0NvbXBvbmVudH1cbiAqL1xuXG5jbGFzcyBNYXJrZG93blByZXZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSB0aGUgaW5pdGlhbCBlZGl0b3Igc3RhdGUuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zdGF0ZSA9IHtzdGF0ZTogRG9jU3RvcmUuZ2V0Q29udGVudCgpfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIERvY1N0b3JlLm9uKFwiY29udGVudCB1cGRhdGVcIiwgKHN0YXRlKT0+e1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7c3RhdGV9KVxuICAgIH0pO1xuICB9XG5cblxuICBzdHlsZSA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMUUxRTFFJyxcbiAgICBjb2xvcjogJyNENEQ0RDQnXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogUmVuZGVyIHRoZSBleGFtcGxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGUgPSB7dGhpcy5zdHlsZX0+XG4gICAgICAgIDxwIHN0eWxlPXt7dGV4dEFsaWduOidjZW50ZXInfX0+e0RvY1N0b3JlLmZpbGVOYW1lfTwvcD5cbiAgICAgICAgPEVkaXRvclxuICAgICAgICAgIHNjaGVtYT17c2NoZW1hfVxuICAgICAgICAgIHN0YXRlPXt0aGlzLnN0YXRlLnN0YXRlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogT24gY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICAgKi9cblxuICBvbkNoYW5nZSA9IChzdGF0ZSkgPT4ge1xuICAgICAvL3RoaXMuc2V0U3RhdGUoeyBzdGF0ZSB9KVxuICAgIGRpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJVUERBVEVfQ09OVEVOVFwiLFxuICAgICAgc3RhdGUsXG4gICAgfSk7XG4gIH1cblxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBNYXJrZG93blByZXZpZXdcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvZWRpdG9yLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic2xhdGVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJzbGF0ZVwiXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInByaXNtanNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJwcmlzbWpzXCJcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJmc1wiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZWN0cm9uXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZWxlY3Ryb25cIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCB7IERpc3BhdGNoZXIgfSA9IHJlcXVpcmUgKFwiZmx1eFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlzcGF0Y2hlclxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvZGlzcGF0Y2hlci5qcyIsIlxuaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ2V2ZW50cydcbmltcG9ydCBkaXNwYXRjaGVyIGZyb20gJy4vZGlzcGF0Y2hlcidcbmltcG9ydCB7UGxhaW4gfSBmcm9tICdzbGF0ZSdcbmltcG9ydCBmcyBmcm9tICdmcydcblxuY2xhc3MgRG9jU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgc3VwZXIoKVxuICB0aGlzLmNvbnRlbnQgPSBQbGFpbi5kZXNlcmlhbGl6ZShcIlwiKVxuICB0aGlzLmZpbGVOYW1lID0gJ3VuZGlmaWVuJ1xuICB0aGlzLmZpbGVQYXRoID0gdW5kZWZpbmVkXG4gIH1cbiAgZ2V0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50XG4gIH1cbiAgdXBkYXRlQ29udGVudCh0ZXh0KSB7XG4gICAgdGhpcy5jb250ZW50ID0gdGV4dFxuICAgIHRoaXMuc2F2ZUZpbGUoKVxuICAgIHRoaXMuZW1pdCgnY29udGVudCB1cGRhdGUnLHRoaXMuY29udGVudClcbiAgfVxuXG4gIGNoYW5nZUZpbGUoZmlsZVBhdGgpIHtcbiAgICBjb25zb2xlLmxvZygnZmlsZScsZmlsZVBhdGgpXG4gICAgY29uc3QgZmlsZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwndXRmOCcpXG4gICAgdGhpcy5jb250ZW50ID0gUGxhaW4uZGVzZXJpYWxpemUoZmlsZSlcbiAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG4gICAgY29uc3QgcCA9IHRoaXMuZmlsZVBhdGguc3BsaXQoJy8nKSBcbiAgICB0aGlzLmZpbGVOYW1lID0gcFtwLmxlbmd0aCAtMV1cbiAgICB0aGlzLmVtaXQoJ2NvbnRlbnQgdXBkYXRlJyx0aGlzLmNvbnRlbnQpXG4gIH1cblxuICBzYXZlRmlsZSgpe1xuICAgIGlmKHRoaXMuZmlsZVBhdGgpIHtcbiAgICAgIGNvbnN0IGZpbGVTb3VyY2UgPSBQbGFpbi5zZXJpYWxpemUodGhpcy5jb250ZW50KVxuICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLmZpbGVQYXRoLGZpbGVTb3VyY2UsJ3V0ZjgnKVxuICAgIH1cbiAgICBcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY29udGVudCA9IFBsYWluLmRlc2VyaWFsaXplKFwiXCIpXG4gICAgdGhpcy5maWxlTmFtZSA9ICd1bmRpZmllbidcbiAgICB0aGlzLmZpbGVQYXRoID0gdW5kZWZpbmVkXG4gICAgdGhpcy5lbWl0KCdjb250ZW50IHVwZGF0ZScsdGhpcy5jb250ZW50KVxuICB9XG5cbiAgc2F2ZU5ld0ZpbGUoZmlsZVBhdGgpe1xuICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlUGF0aFxuICAgIGNvbnN0IHAgPSB0aGlzLmZpbGVQYXRoLnNwbGl0KCcvJykgXG4gICAgdGhpcy5maWxlTmFtZSA9IHBbcC5sZW5ndGggLTFdXG4gICAgY29uc3QgZmlsZVNvdXJjZSA9IFBsYWluLnNlcmlhbGl6ZSh0aGlzLmNvbnRlbnQpXG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCxmaWxlU291cmNlLCd1dGY4JylcbiAgICAvLyBjb25zb2xlLmxvZygnc2F2ZScsdGhpcy5jb250ZW50LnRleHRzKVxuICB9XG5cbiAgaGFuZGxlQWN0aW9ucyhhY3Rpb24pIHtcbiAgICBcbiAgICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJVUERBVEVfQ09OVEVOVFwiOiB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGVudChhY3Rpb24uc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJPUEVOX0ZJTEVcIjoge1xuICAgICAgICB0aGlzLmNoYW5nZUZpbGUoYWN0aW9uLmZpbGVQYXRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTkVXX0ZJTEVcIjoge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlNBVkVfRklMRV9BU1wiOiB7XG4gICAgICAgIHRoaXMuc2F2ZU5ld0ZpbGUoYWN0aW9uLmZpbGVQYXRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBkb2NTdG9yZSA9IG5ldyBEb2NTdG9yZSgpXG5kaXNwYXRjaGVyLnJlZ2lzdGVyKGRvY1N0b3JlLmhhbmRsZUFjdGlvbnMuYmluZChkb2NTdG9yZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBkb2NTdG9yZVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9zdG9yZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9saWIvRGlzcGF0Y2hlcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZsdXgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGlzcGF0Y2hlclxuICogXG4gKiBAcHJldmVudE11bmdlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgX3ByZWZpeCA9ICdJRF8nO1xuXG4vKipcbiAqIERpc3BhdGNoZXIgaXMgdXNlZCB0byBicm9hZGNhc3QgcGF5bG9hZHMgdG8gcmVnaXN0ZXJlZCBjYWxsYmFja3MuIFRoaXMgaXNcbiAqIGRpZmZlcmVudCBmcm9tIGdlbmVyaWMgcHViLXN1YiBzeXN0ZW1zIGluIHR3byB3YXlzOlxuICpcbiAqICAgMSkgQ2FsbGJhY2tzIGFyZSBub3Qgc3Vic2NyaWJlZCB0byBwYXJ0aWN1bGFyIGV2ZW50cy4gRXZlcnkgcGF5bG9hZCBpc1xuICogICAgICBkaXNwYXRjaGVkIHRvIGV2ZXJ5IHJlZ2lzdGVyZWQgY2FsbGJhY2suXG4gKiAgIDIpIENhbGxiYWNrcyBjYW4gYmUgZGVmZXJyZWQgaW4gd2hvbGUgb3IgcGFydCB1bnRpbCBvdGhlciBjYWxsYmFja3MgaGF2ZVxuICogICAgICBiZWVuIGV4ZWN1dGVkLlxuICpcbiAqIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGlzIGh5cG90aGV0aWNhbCBmbGlnaHQgZGVzdGluYXRpb24gZm9ybSwgd2hpY2hcbiAqIHNlbGVjdHMgYSBkZWZhdWx0IGNpdHkgd2hlbiBhIGNvdW50cnkgaXMgc2VsZWN0ZWQ6XG4gKlxuICogICB2YXIgZmxpZ2h0RGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjb3VudHJ5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDb3VudHJ5U3RvcmUgPSB7Y291bnRyeTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjaXR5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDaXR5U3RvcmUgPSB7Y2l0eTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgYmFzZSBmbGlnaHQgcHJpY2Ugb2YgdGhlIHNlbGVjdGVkIGNpdHlcbiAqICAgdmFyIEZsaWdodFByaWNlU3RvcmUgPSB7cHJpY2U6IG51bGx9XG4gKlxuICogV2hlbiBhIHVzZXIgY2hhbmdlcyB0aGUgc2VsZWN0ZWQgY2l0eSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY2l0eS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ2l0eTogJ3BhcmlzJ1xuICogICB9KTtcbiAqXG4gKiBUaGlzIHBheWxvYWQgaXMgZGlnZXN0ZWQgYnkgYENpdHlTdG9yZWA6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY2l0eS11cGRhdGUnKSB7XG4gKiAgICAgICBDaXR5U3RvcmUuY2l0eSA9IHBheWxvYWQuc2VsZWN0ZWRDaXR5O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogV2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgY291bnRyeSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY291bnRyeS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ291bnRyeTogJ2F1c3RyYWxpYSdcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGJvdGggc3RvcmVzOlxuICpcbiAqICAgQ291bnRyeVN0b3JlLmRpc3BhdGNoVG9rZW4gPSBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY291bnRyeS11cGRhdGUnKSB7XG4gKiAgICAgICBDb3VudHJ5U3RvcmUuY291bnRyeSA9IHBheWxvYWQuc2VsZWN0ZWRDb3VudHJ5O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogV2hlbiB0aGUgY2FsbGJhY2sgdG8gdXBkYXRlIGBDb3VudHJ5U3RvcmVgIGlzIHJlZ2lzdGVyZWQsIHdlIHNhdmUgYSByZWZlcmVuY2VcbiAqIHRvIHRoZSByZXR1cm5lZCB0b2tlbi4gVXNpbmcgdGhpcyB0b2tlbiB3aXRoIGB3YWl0Rm9yKClgLCB3ZSBjYW4gZ3VhcmFudGVlXG4gKiB0aGF0IGBDb3VudHJ5U3RvcmVgIGlzIHVwZGF0ZWQgYmVmb3JlIHRoZSBjYWxsYmFjayB0aGF0IHVwZGF0ZXMgYENpdHlTdG9yZWBcbiAqIG5lZWRzIHRvIHF1ZXJ5IGl0cyBkYXRhLlxuICpcbiAqICAgQ2l0eVN0b3JlLmRpc3BhdGNoVG9rZW4gPSBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY291bnRyeS11cGRhdGUnKSB7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIG1heSBub3QgYmUgdXBkYXRlZC5cbiAqICAgICAgIGZsaWdodERpc3BhdGNoZXIud2FpdEZvcihbQ291bnRyeVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcbiAqICAgICAgIC8vIGBDb3VudHJ5U3RvcmUuY291bnRyeWAgaXMgbm93IGd1YXJhbnRlZWQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiAgICAgICAvLyBTZWxlY3QgdGhlIGRlZmF1bHQgY2l0eSBmb3IgdGhlIG5ldyBjb3VudHJ5XG4gKiAgICAgICBDaXR5U3RvcmUuY2l0eSA9IGdldERlZmF1bHRDaXR5Rm9yQ291bnRyeShDb3VudHJ5U3RvcmUuY291bnRyeSk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgdXNhZ2Ugb2YgYHdhaXRGb3IoKWAgY2FuIGJlIGNoYWluZWQsIGZvciBleGFtcGxlOlxuICpcbiAqICAgRmxpZ2h0UHJpY2VTdG9yZS5kaXNwYXRjaFRva2VuID1cbiAqICAgICBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICAgIHN3aXRjaCAocGF5bG9hZC5hY3Rpb25UeXBlKSB7XG4gKiAgICAgICAgIGNhc2UgJ2NvdW50cnktdXBkYXRlJzpcbiAqICAgICAgICAgY2FzZSAnY2l0eS11cGRhdGUnOlxuICogICAgICAgICAgIGZsaWdodERpc3BhdGNoZXIud2FpdEZvcihbQ2l0eVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcbiAqICAgICAgICAgICBGbGlnaHRQcmljZVN0b3JlLnByaWNlID1cbiAqICAgICAgICAgICAgIGdldEZsaWdodFByaWNlU3RvcmUoQ291bnRyeVN0b3JlLmNvdW50cnksIENpdHlTdG9yZS5jaXR5KTtcbiAqICAgICAgICAgICBicmVhaztcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBgY291bnRyeS11cGRhdGVgIHBheWxvYWQgd2lsbCBiZSBndWFyYW50ZWVkIHRvIGludm9rZSB0aGUgc3RvcmVzJ1xuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MgaW4gb3JkZXI6IGBDb3VudHJ5U3RvcmVgLCBgQ2l0eVN0b3JlYCwgdGhlblxuICogYEZsaWdodFByaWNlU3RvcmVgLlxuICovXG5cbnZhciBEaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGlzcGF0Y2hlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcGF0Y2hlcik7XG5cbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faXNIYW5kbGVkID0ge307XG4gICAgdGhpcy5faXNQZW5kaW5nID0ge307XG4gICAgdGhpcy5fbGFzdElEID0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdpdGggZXZlcnkgZGlzcGF0Y2hlZCBwYXlsb2FkLiBSZXR1cm5zXG4gICAqIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGB3YWl0Rm9yKClgLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gX3ByZWZpeCArIHRoaXMuX2xhc3RJRCsrO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tpZF0gPSBjYWxsYmFjaztcbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjYWxsYmFjayBiYXNlZCBvbiBpdHMgdG9rZW4uXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyKGlkKSB7XG4gICAgIXRoaXMuX2NhbGxiYWNrc1tpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci51bnJlZ2lzdGVyKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbaWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgdGhlIGNhbGxiYWNrcyBzcGVjaWZpZWQgdG8gYmUgaW52b2tlZCBiZWZvcmUgY29udGludWluZyBleGVjdXRpb25cbiAgICogb2YgdGhlIGN1cnJlbnQgY2FsbGJhY2suIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgYSBjYWxsYmFjayBpblxuICAgKiByZXNwb25zZSB0byBhIGRpc3BhdGNoZWQgcGF5bG9hZC5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uIHdhaXRGb3IoaWRzKSB7XG4gICAgIXRoaXMuX2lzRGlzcGF0Y2hpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IE11c3QgYmUgaW52b2tlZCB3aGlsZSBkaXNwYXRjaGluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGlkcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBpZCA9IGlkc1tpaV07XG4gICAgICBpZiAodGhpcy5faXNQZW5kaW5nW2lkXSkge1xuICAgICAgICAhdGhpcy5faXNIYW5kbGVkW2lkXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogQ2lyY3VsYXIgZGVwZW5kZW5jeSBkZXRlY3RlZCB3aGlsZSAnICsgJ3dhaXRpbmcgZm9yIGAlc2AuJywgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAhdGhpcy5fY2FsbGJhY2tzW2lkXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogYCVzYCBkb2VzIG5vdCBtYXAgdG8gYSByZWdpc3RlcmVkIGNhbGxiYWNrLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9pbnZva2VDYWxsYmFjayhpZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgcGF5bG9hZCB0byBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2gocGF5bG9hZCkge1xuICAgICEhdGhpcy5faXNEaXNwYXRjaGluZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEaXNwYXRjaC5kaXNwYXRjaCguLi4pOiBDYW5ub3QgZGlzcGF0Y2ggaW4gdGhlIG1pZGRsZSBvZiBhIGRpc3BhdGNoLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydERpc3BhdGNoaW5nKHBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZva2VDYWxsYmFjayhpZCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3N0b3BEaXNwYXRjaGluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhpcyBEaXNwYXRjaGVyIGN1cnJlbnRseSBkaXNwYXRjaGluZy5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuaXNEaXNwYXRjaGluZyA9IGZ1bmN0aW9uIGlzRGlzcGF0Y2hpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRGlzcGF0Y2hpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNhbGxiYWNrIHN0b3JlZCB3aXRoIHRoZSBnaXZlbiBpZC4gQWxzbyBkbyBzb21lIGludGVybmFsXG4gICAqIGJvb2trZWVwaW5nLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuX2ludm9rZUNhbGxiYWNrID0gZnVuY3Rpb24gX2ludm9rZUNhbGxiYWNrKGlkKSB7XG4gICAgdGhpcy5faXNQZW5kaW5nW2lkXSA9IHRydWU7XG4gICAgdGhpcy5fY2FsbGJhY2tzW2lkXSh0aGlzLl9wZW5kaW5nUGF5bG9hZCk7XG4gICAgdGhpcy5faXNIYW5kbGVkW2lkXSA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB1cCBib29ra2VlcGluZyBuZWVkZWQgd2hlbiBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9zdGFydERpc3BhdGNoaW5nID0gZnVuY3Rpb24gX3N0YXJ0RGlzcGF0Y2hpbmcocGF5bG9hZCkge1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgdGhpcy5faXNQZW5kaW5nW2lkXSA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNIYW5kbGVkW2lkXSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nUGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGJvb2trZWVwaW5nIHVzZWQgZm9yIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuX3N0b3BEaXNwYXRjaGluZyA9IGZ1bmN0aW9uIF9zdG9wRGlzcGF0Y2hpbmcoKSB7XG4gICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdQYXlsb2FkO1xuICAgIHRoaXMuX2lzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gRGlzcGF0Y2hlcjtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZmx1eC9saWIvRGlzcGF0Y2hlci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZXZlbnRzXCJcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=